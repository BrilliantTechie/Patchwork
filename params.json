{"name":"Patchwork","tagline":"A library for modifying .NET assemblies.","body":"# Patchwork\r\n----\r\n**License:** [MIT License](http://opensource.org/licenses/MIT) \r\n[**Latest Version:** 0.9](https://github.com/GregRos/Patchwork/releases/latest)\r\n----\r\n**Patchwork** is a framework for integrating your own code into existing .NET assemblies (\"patching\" them). It allows you to edit, create, or replace things such as types, properties, and methods in a simple, straight-forward, and declarative way, using attributes.\r\n\r\nThe framework lets you basically rewrite entire programs, such as games, according to your whims (as long as they're written in a .NET language of course). Little in the code is beyond your control, and you can write it all using the same tools as the original developers. \r\n\r\nYou write code in C# or another language, and that code is injected into the target assembly according to your patching declarations. It is minimally transformed, fixing references to such things as types and methods, so that it remains valid at the point of injection.\r\n\r\nThe framework was written with game modding in mind, but can be used for any purpose.\r\n\r\nThe framework is mostly documented, including the non-public members.\r\n\r\n## Moddable Games\r\nLike I said above, the library was written with game modding in mind. In general, you can mod two kinds of games with it: i\r\n### .NET/XNA\r\nGames that run on .NET/XNA. You can mod pretty much anything in this case. However, there aren't many popular XNA titles.\r\n\r\n### Unity/.NET\r\nGames that run on Unity and use .NET for their game logic (mainly C#, but some also use other languages). \r\n\r\nLuckily, the majority of popular Unity titles do primarily use .NET.\r\n\r\nModding in this case is somewhat more limited, as you can only mod the game logic in the scripts, but from experience, you still have vastly more power than typical official modding tools would give you.\r\n\r\n## Components \r\nThe framework consists of several separate components. \r\n\r\n### PatchworkLauncher (PWL)\r\nThis is the end-user patching GUI. Users use this program to apply your modifications to their games or applications. It is most convenient to download it from the [Releases](https://github.com/GregRos/Patchwork/releases) section.\r\n\r\nYou also use this program to test your patch assembly for yourself. \r\n\r\n#### OpenAssemblyCreator (OAC)\r\nThis is a command-line tool packaged with PWL. It allows you to create an open assembly to reference in your patch assembly. More on this later.\r\n\r\n### Patchwork.Attributes (PWA)\r\nThe `Patchwork.Attributes` assembly is meant to be referenced by your patch assembly, and is compiled with framework version 2.0 to improve compatibility. It contains the attributes that serve as patching instructions. It has no dependencies.\r\n\r\nYou can conveniently get this package from [NuGet: Patchwork.Attributes](https://www.nuget.org/packages/Patchwork.Attributes/) and reference it in your patch assembly.\r\n\r\n### Patchwork.Engine\r\nThis is the library that actually does the patching. It can be used separately from the GUI. However, you generally wouldn't want to do so unless you wanted to write a new front-end, some kind of script, or... had some other reason.\r\n\r\nNaturally, it's packaged with the launcher.\r\n\r\n## Getting Started\r\nFirst, get the latest PWL release from the releases section. \r\n\r\nUnless someone else already wrote it, you'll need to write an `AppInfo.dll` file for the game you want to patch. See the section on the launcher for more information.\r\n\r\nNext, create a new project (preferably with a name ending with `.pw` for reasons explained later). \r\n\r\nReference the `Patchwork.Attributes` assembly from that project.\r\n\r\nSince you probably don't want to copy files around manually, you should take advantage of the `DontCopyFiles` option in the `Preferences` section of the `preferences.pw.xml` file. It lets you add files to your mod list without copying them to a mods folder, so you can just add the result of your build directly.\r\n\r\nThat's... it. You're ready to go. Good luck out there. \r\n\r\nBy the way, patching using the launcher creates a dependency on `Patchwork.Attributes` in the target (patched) assembly.\r\n\r\n## Overview\r\nThere are a few stages to writing a patch.\r\n\r\n### Finding What to Patch\r\nBefore you start writing your patch assembly, you need to find what you want to patch. This involves decompiling the target assembly. See *Recommended Decompilers* below for more information. \r\n\r\nAlso, take note of the target framework version of the assembly, as for the most reliable results you'd want your patch to be built against the same framework version.\r\n\r\n### Creating an Open Assembly\r\nYou also need to have an \"open\" version of the assembly you want to patch. \"Open\" here means that all of its members are public and non-sealed. \r\n\r\nTo see why this is required, imagine you have a class like:\r\n\r\n\tclass Player {\r\n\t\tprivate int _hitpoints;\r\n\t\t\r\n\t\tpublic void GetHit() {\r\n\t\t\t_hitpoints--;\r\n\t\t}\r\n\t}\r\n\t\r\nAnd you want to overwrite the `GetHit` method to perform `_hitpoints++` instead. \r\n\r\nThe problem is that `_hitpoints` can only be accessed from inside the class `Player`. But you have to write the code `_hitpoints++` in your own assembly. The framework will inject it into the correct spot, but your C# compiler doesn't know that and won't let you access the member.\r\n\r\nChanging all members to public allows you to access the member. However, it can cause problems too. You might make a mistake and illegally refer to a non-public member, for example.\r\n\r\nOn the brighter side, the `PEVerify` tool (which executed automatically) will catch any accessibility issues and warn you about them.\r\n\r\nYou create an open assembly using the command-line tool `OpenAssemblyCreator.exe`, also called OAC. Using it is straight-forward. \r\n### Creating the Patch Assembly\r\nYou patch an existing target assembly by writing a *patch assembly* (probably with the target assembly referenced), and load it as input to patch a \"target\" assembly. This assembly contains attributes that are used as patching instructions. \r\n\r\nYou need to specify the `PatchAssembly` attribute on any such patch assembly.\r\n\r\n#### Writing It\r\nPatch assemblies consist of patch types, which are new types or just sets of modifications to an existing type. Here is a simple example:\r\n\r\n\t[ModifiesType] //means the class modifies another class\r\n\tclass AttackMod : Attack {\r\n\t\t//note that by default it modifies its parent class, if any, \r\n\t\t//so this class modifies Attack.\r\n\t\t\r\n\t\t[NewMember] //this means a new method will be injected into the type\r\n\t\tpublic Hit() {\r\n\t\t\t//whatever you want to do\r\n\t\t}\r\n\t\t\r\n\t\t[ModifiesMember(\"ExistingMethod\")]\r\n\t\tpublic void ExistingMethodRevised() {\r\n\t\t\t//your instructions will replace those of ExistingMethod,\r\n\t\t\t//as defined in the modified type\r\n\t\t}\r\n\t}\r\n\t\r\n\t[NewType]\r\n\tpublic class MyNewType {\r\n\t\t//No need to specify attributes here.\r\n\t\tprivate readonly string _myField;\r\n\t\t\r\n\t\tpublic int MyMethod(int x) { ... }\r\n\t}\r\nYou can add any members to the type, and attach the right attributes to them, depending on whether you want them to modify existing members or create new ones. (If you create a new type, there are no existing members to modify, of course).\r\n\r\nCompiler-generated members are imported as new members by default, even if they don't have a patching attribute.\r\n\r\n#### Format and Additional Info\r\nThe recommended extension for patch assemblies is `pw.dll`.\r\n\r\nIn order for a patch assembly to work with the Patchwork launcher, it must define a class with the following requirements.\r\n\r\n1. It implements `Patchwork.Attributes.IPatchInfo`\r\n2. It is decorated with `Patchwork.Attributes.PatchInfoAttribute`.\r\n3. It has a default constructor.\r\n\r\nThere must be only one such class in the assembly.\r\n\r\nThe class should not contain any references to any types not found in the GAC or in `Patchwork.Attributes`.\r\n\r\nIt is instantiated in a separate AppDomain from the rest of the application, and this AppDomain is unloaded if the user removes it from the patch list.\r\n\r\nThe `PatchInfo` is needed to tell the launcher what file to patch. The class can find the file based on the operating system and other information.\r\n\r\n### Patching\r\nThe patch is mostly viewed as data by the patchwork launcher. To patch another assembly with your patch assembly, you must load the `pw.dll` file into the launcher and then start the game.\r\n\r\nThat's it.\r\n\r\n\r\n## Patchwork Launcher\r\nEach launcher executable is meant to work with one game. To work with a game, someone must write an `AppInfo.dll` assembly (as described below) and put it in the launcher directory. The launcher loads it on startup and uses it to get information about the game. The launcher should be distributed with this file.\r\n\r\nThe launcher allows users to manage patches for the chosen game, as well as change the order in which they are applied. It keeps the original game files on disk and switches them with modded files when the user launches the game. It only patches the files when necessary. It stays in the background, and once the game is exited, the launcher switches to the original files once more. \r\n\r\nOnce it starts up, the launcher also checks the state of the files and fixes them if necessary, in case it was terminated unexpectedly.\r\n\r\nThe launcher works on Mono and is written in Windows Forms for that purpose.\r\n\r\n### AppInfo.dll\r\nThis file is required for the launcher to work correctly with a game. It's an assembly (the name doesn't matter) containing a type that:\r\n\r\n1. Inherits from `Patchwork.Attributes.AppInfoFactory`.\r\n2. Is decorated with `Patchwork.Attributes.AppInfoFactoryAttribute`.\r\n3. Has a default constructor.\r\n\r\nThis type has a `CreateInfo` method that returns an `Pathcwork.Attributes.AppInfo` object which provides information about the game.\r\n\r\nThere must be only one such class in the assembly.\r\n\r\nThis class is instantiated during runtime, in the same AppDomain as the original application. The launcher can't start if the file is invalid or not found.\r\n\r\nIf this file is not found, an error message is generated and the launcher doesn't work properly.\r\n\r\n## Available Attributes\r\nThese attributes are located in the `Patchwork.Attributes` namespace. Note that this isn't necessarily a full list.\r\n\r\n### Note about attribute constructors\r\nAttributes that require types as parameters invariably have an `object` parameter instead of a `Type` parameter.\r\n\r\nThis is a necessary workaround. You still use `typeof(T)` to specify the type.\r\n\r\n### PatchingAssembly\r\nYou *must* add this attribute to your assembly (using `[assembly: PatchingAssembly]`) for it to be recognized as an assembly that contains patching types.\r\n\r\n### ModifiesType(name)\r\nSays that your type modifies another type in the game. Allows you to use `ModifiesMember` within that type.\r\n\r\nYou can specify the full name of the type you want to modify, or let PW infer it.\r\n\r\n### ReplacesType(name)\r\nAlternative version of the above attribute. Removes all the members of the type, overwriting it with your own members. Currently implemented only on enums. `ModifiesMember` attributes are invalid, since they have no meaning.\r\n\r\n### ModifiesMember(name,scope)\r\nModifies the member, such as its accessibility, body, and maybe other things. scope controls the scope of the modification.\r\n\r\n### ModifiesAccessibility(name)\r\nRestricted form of the last attribute. Modifies just the accessibility to be identical to your member. \r\n\r\nProvided for convenience.\r\n\r\n### NewMember(altName)\r\nIntroduce this as a new member to the patched type. If you specify `altName`, the member will be introduced under this name instead.\r\n\r\nIf the member collides with an existing member, its name will be suffixed with `_$pw$_RANDOM`, e.g. `_$pw$_dfRff`.  A warning will be emitted.\r\n\r\n### DuplicatesBody(methodName, declaringType)\r\nPut this on a method marked with NewMember or ModifiesMember to insert the body of another method into it. Optionally, you can provide the type that declares the method; otherwise, it defaults to the type being modified.\r\nYou can use it to call original members in the modified type, as it takes the body from the original assembly.\r\n\r\n### NewType(altName, altNamespace)\r\nPut this attribute on a type to denote it is a new type that will be introduced into the assembly.\r\n\r\nThe name of the type will normally be the same as it is in your assembly, including namespaces and so forth. However, `altName` and `altNamespace` allow you to specify an alternative name/namespace.\r\n\r\nIn case of a collision, the type name will be suffixed with `_$pw$_RANDOM`, e.g. `_$pw$_dffERr`. A warning will be emitted.\r\n\r\nYou can create any kind of type you like, whether interface, struct, or class. You can have inheritance, generic type parameters, put constraints on those parameters, etc. Anything goes.\r\n\r\nYou don't need to use creation attributes on any of your type's members, except for other types. They will be considered to have the `NewMember` attribute. \r\n\r\nYou can put `ModifiesType` on a nested type inside a `NewType`, but not `ModifiesMember`. \r\n\r\n\r\n### RemoveThisMember\r\n\r\nRemoves a member of the same name from the modified type. Added for the sake of completeness.\r\n\r\nAfter using it, it's wise to mark the member using the `[Obsolete]` attribute so you don't invoke it by accident.\r\n\r\nPW will not check if this action causes an error, but errors may still come up in the patching process later on.\r\n\r\nIt is not possible to remove types.\r\n\r\n### DisablePatching\r\nDisables the patching of this element and all child elements, including nested types. \r\n\r\nModifications will not be performed, and new types will not be created.\r\n\r\n### MemberAlias(memberName, declaringType, aliasCallMode)\r\nThis attribute lets you create an alias for another member. When Patchwork encounters a reference to the alias member in your code, it will replace that reference with the aliased member.\r\n\r\nIt is useful for making explicit calls to things such as base class constructors. If `aliasCallMode == AliasCallMode.NonVirtual`, a call to the member is translated to a non-virtual call, bypassing any overrides. This will allow you to inject `base.OverriddenMethod()` sorts of calls into the methods you modify.\r\n\r\n### PatchworkDebugRegister(memberName, declaringType)\r\nThis is a special attribute for debugging purposes.  You can specify a static string member that will be used as a debug register for the current method. It will be updated with information about which line number is going to be executed next. It lets you find the line number at which an exception was thrown (or something else happened), when the exception does not contain this information. \r\n\r\nFor example, the register can contain the following after an exception is thrown and is caught in the same method:\r\n\r\n\t10 ⇒ 11 ⇒ 45 ⇒ 46 ⇒ 47 ⇒ 251 ⇒ 252\r\n\r\nIf the catch clause was at line 251, then line 47 is the one that threw the exception.\r\n\r\nThis is a hack, but it can be quite useful.\r\n\r\n### ToggleFieldAttributes(fieldAttributes)\r\nThis custom attribute toggles (XORs) the intrinsic deceleration attributes of the patched field with the input attributes. It must be used with an action attribute, such as `ModifiesMember`.\r\n\r\nThis attribute allows you to change accessibility, as well as more arcane things. Using it incautiously can cause runtime errors.\r\n\r\n### ToggleMethodAttributes(methodAttributes)\r\nThis custom attribute toggles (XORs) the intrinsic deceleration attributes of the patched method with the input attributes. It must be used with an action attribute, such as `ModifiesMember`.\r\n\r\nThis attribute allows you to change accessibility, add/remove the `sealed` qualifier, and perform other, more arcane tasks. Using it incautiously can cause runtime errors.\r\n\r\n## Naming Conventions\r\nIt is best practice to follow certain naming conventions when writing your patch assembly.\r\n\r\nYou should prefix each code element according to the action the framework is expected to perform on it. That way, you will be able to tell what sort of member it is just by glancing at the name, and your code will be more readable to others.\r\n\r\n| Function                                                   | Form            | Related Attribute            |\r\n|---------------------------------------------------------   |-----------------|------------------------------|\r\n| Modification of `Name` type/member from the original assembly | `mod_Name`        | `ModifiesType`, `ModifiesMember` |\r\n| Duplicate of `Name` in the modified type                  | `orig_Name`       | `DuplicatesBody`               |\r\n| Duplicate of `Name` in type `Type` in the original assembly | `orig_Type_Name` | `DuplicatesBody`               |\r\n| Alias of `Name` in type `Type`                              | `alias_Type_Name` | `MemberAlias`                  |\r\n| New type or member                                      | (none)          | `NewMember`, `NewType`           \r\n\r\nFor instance constructors, use the name `ctor` and for static ones use `cctor`. \r\n\r\n(none) means that you should not prefix the name with anything.\r\n\r\n\r\n\r\n## Specific Issues\r\n\r\n### About Overloading\r\nWhen you put an attribute on a code element, the framework will usually use that element's name (or an alternative name you supply) and, in the case of methods and properties, their parameters, to find what to modify.\r\n\r\nTo modify one of several overloaded methods, you just need to duplicate that method's parameter types exactly.\r\n\r\nNote that return types of existing methods cannot be modified.\r\n\r\n### Modifying/Creating Properties\r\nNote that to modify a property's `get` and `set` accessors, you need to put `ModifiesMember` *on the accessor you want to modify*, not on the property deceleration. The accessors are actually methods, and it's those the framework modifies.\r\n\r\nHowever, you can choose to put `NewMember` on the property, in which case the accessors will be created automatically.\r\n\r\nThis also applies to the property's accessibility. In the IL, only get/set methods have accessibility, so if you want to modify it you have to put the attribute on the accessor, possibly on both.\r\n\r\nYou might need to use the explicit name of the property accessor to modify it (if your property is named differently). Accessor names are normally `get_{Property}` and `set_{Property}`.\r\n\r\nPretty much *the only* time you'd want to use `ModifiesMember` attribute on a property itself is when you want to create a brand new accessor for the property. In this case, the property data must be modified. You'll still put the `NewMember` attribute on the new accessor.  \r\n\r\n### Modifying Constructors\r\nYou can't create constructors for existing types, but you can modify existing ones. Constructors are just methods called `.ctor`. You just need to duplicate their signature in a normal method, and change the modified member name in the attribute. Every object has a default `.ctor`.\r\n\r\nStatic constructors are called `.cctor`. Not all types have static constructors.\r\n\r\nNote that constructors also contain the type's initializers, so you may need to copy those or the class might not work correctly. \r\n\r\nInstance constructors normally contain explicit calls to a base class constructor (e.g. `base::.ctor()`). It is best practice to add this call. This can be achieved by using the `MemberAlias` attribute. For example:\r\n\r\n\t[MemberAlias(\".ctor\", typeof(object))]\r\n\tprivate void object_ctor() {\r\n\t\t//this is an alias for object::.ctor()\r\n\t}\r\n\t\r\n\t[ModifiesMember(\".ctor\")]\r\n\tpublic void CtorNew() {\r\n\t\tobject_ctor();\r\n\t\tIEModOptions.LoadFromPrefs();\r\n\t}\r\n\r\nStatic constructors do not contain such a call.\r\n\r\n### Nested Types\r\n\r\nYou can have your nested types modify other types, or you can modify other nested types, without regard to the nesting level. The location of your nested type doesn't matter, and using `ModifiesType` behaves the same way. \r\n\r\nTo modify a type by name (rather than having PW infer it), you have to give the *full name* of the type, without regard to where the attribute appears.\r\n\r\nIn the IL and in Mono.Cecil, as well as in this framework, you use `/` to indicate nesting. E.g. `Namespace.ContainerClass/Nested/NestedNested`.\r\n\r\nYou can also have a new nested type inside a modification to an existing type. In this case, the nested type will be moved to the modified type.\r\n\r\n### Modifying Explicitly Implemented Methods\r\nThese are regular methods with different actual names. The names are `[INTERFACE_FULL_NAME].Method`. For example, if `IEnumerable<T>.GetEnumerator()` were explicitly implemented, you'd set the member name to:\r\n\r\n\t\tSystem.Collections.Generic.IEnumerable<T>.GetEnumerator\r\n\r\nThe dots are actually part of the name of the method, just like the dot in `.ctor` is. IL doesn't follow C# naming rules.\r\n\r\n## Patching History\r\nThe launcher embeds various attributes in the target assembly that let you see what Patchwork did to it. These are called history attributes. The following are embedded.\r\n\r\nAlso, the patching attributes you use also get embedded, except for `PatchAssembly`.\r\n\r\n### PatchingHistoryAttribute\r\nAbstract parent of all history attributes.\r\n\r\n### PatchedByAssemblyAttribute\r\nContains information about the patch assembly, the original assembly (before patching was performed), and the Patchwork assembly that performed patching.\r\n\r\n### PatchedByMemberAttribute\r\nIndicates the member in the patch assembly that contained the patching instruction to patch this member.\r\n\r\n### PatchedByTypeAttribute\r\nIndicates the type in the patch assembly that contained the patching instruction to patch this type.\r\n\r\n## Limitations\r\nIn this section I'll list the limitations of the library, in terms of the code that it can deal with at this stage, and what it *can't* allow you to do. This section will be updated as more features get worked in.\r\n\r\n### Assemblies\r\n1. Multi-module assemblies won't work properly (either as patches or patch targets). Note that few IDEs (if any) can naturally produce such assemblies, though they can be the result of tools such as ILMerge.\r\n2. Inter-dependencies between multiple patch assemblies haven't been tested.\r\n\r\n### Members\r\n2. You can't add new constructors or finalizers to existing types.\r\n3. Existing declarations can only be modified in limited ways. For example, you can't un-seal a sealed class, change type parameters and their constraints, etc. New members can still be sealed or unsealed, etc, as you prefer. \r\n3. Field initializers don't work in modifying types, except for const fields. This is unlikely to be fixed anytime soon, as it requires pretty tricky IL injection.\r\n\r\n### Language Features\r\n1. `unsafe` context features, like pointers and pinned variables, probably won't work.\r\n2. Various exotic and undocumented (in C#) constructs cannot be used, such as `__arglist`.\r\n\r\n### Other .NET Languages\r\nThis library is for transforming IL, not transforming source code, so it doesn't actually care what language you write in. As long as you put attributes on things that are recognizable in the IL as properties, methods, and classes, it will probably work correctly.\r\n\r\nThat said, you could experience more problems if you write in languages other than C#, simply because they can be compiled to very different IL, and the different input could reveal flaws I never encountered during testing. \r\n\r\nHowever, don't take this as me discouraging you from using other languages. \r\n\r\n\r\n\r\n## Recommended Decompilers\r\nI've tried a number of decompilers. \r\n\r\n1. **[Telerik JustDecompile](http://www.telerik.com/download/justdecompile)**: Probably the best overall decompiler I've tested. It has great search functions, can produce IL as well as C#, good decompilation ability, and has a great interface. Decompilation isn't perfect, as it can't decompile such things as iterators. Tends to handle errors fairly decently.\r\n2. [**ILSpy:**](http://ilspy.net/) This one generates the best source code *by far* from the decompilers I've tested. It can decompile iterators, lambdas, you name it. Unfortunately, it has no search function that deserves the name and handles errors very badly, even when set to IL. The interface is also inconvenient.\r\n3. [**dotPeek**](https://www.jetbrains.com/decompiler): It has a good interface and decent search, with the very helpful ability of finding related (e.g. derived) types, but isn't very good at decompiling compiler-generated code. It can't even handle things like auto-properties.\r\n\r\n## Dependencies\r\n\r\n1. [Mono.Cecil](http://www.mono-project.com/docs/tools+libraries/libraries/Mono.Cecil/), without which none of this would have been possible.\r\n2. [Serilog](http://serilog.net/), used for logging.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}